##### 全排列 KY43

```C++
#include<iostream>
#include<vector>
using namespace std;

vector<string> res;

void fullOrder(string str, string track){
    if(str.size() == track.size()) res.push_back(track);
    for(int i = 0; i < str.size(); ++i){
        //find函数找不到返回s.npos
        if(track.find(str[i]) != track.npos) continue;
        track += str[i];
        fullOrder(str, track);
        track.erase(track.size()-1);  //不能写成track.erase(str[i]); 应该写下标 而不是某个字符
    }
}

int main(){
    string str;
    cin >> str;
    string track = "";
    fullOrder(str, track);
    for(int i = 0; i < res.size(); ++i) cout << res[i] << endl;
}
```

##### 玛雅人的密码 KY12

```C++
#include<iostream>
#include<string>
#include<queue>
#include<map>
using namespace std;

struct Status{
    string s;
    int step;
    Status(string str, int t): s(str), step(t) {}
};

queue<Status> q;

map<string, bool> isVisited;

void bfs(string s){
    q.push(Status(s, 0));
    isVisited[s] = true;
    while(!q.empty()){
        Status ns = q.front();
        string ss = ns.s;
        q.pop();
        if(ss.find("2012") != string::npos){
            cout << ns.step << endl;
            return;
        }
        for(int i = 0; i < ss.size()-2; ++i){
            swap(ss[i], ss[i+1]);  //ss别写成s
            if(!isVisited[ss]){
                q.push(Status(ss, ns.step+1));
                isVisited[ss] = true;
            }
            swap(ss[i], ss[i+1]); //记得换回来
        }
    }
    cout << -1 << endl;
}

int main(){
    int n;
    while(cin >> n){
        string s;
        cin >> s;
        bfs(s);
    }
    
    return 0;
}
```
